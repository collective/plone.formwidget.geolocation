{"version":3,"file":"chunks/687.a1fbda8f47da0d886182.min.js","mappings":"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","sources":["webpack://plone.formwidget.geolocation/./node_modules/leaflet.locatecontrol/src/L.Control.Locate.js"],"sourcesContent":["/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n(function (factory, window) {\n     // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders\n     // for details on how to structure a leaflet plugin.\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        if (typeof window !== 'undefined' && window.L) {\n            module.exports = factory(L);\n        } else {\n            module.exports = factory(require('leaflet'));\n        }\n    }\n\n    // attach your plugin to the global 'L' variable\n    if (typeof window !== 'undefined' && window.L){\n        window.L.Control.Locate = factory(L);\n    }\n} (function (L) {\n    const LDomUtilApplyClassesMethod = (method, element, classNames) => {\n        classNames = classNames.split(' ');\n        classNames.forEach(function(className) {\n            L.DomUtil[method].call(this, element, className);\n        });\n    };\n\n    const addClasses = (el, names) => LDomUtilApplyClassesMethod('addClass', el, names);\n    const removeClasses = (el, names) => LDomUtilApplyClassesMethod('removeClass', el, names);\n\n    /**\n     * Compatible with L.Circle but a true marker instead of a path\n     */\n    const LocationMarker = L.Marker.extend({\n        initialize(latlng, options) {\n            L.Util.setOptions(this, options);\n            this._latlng = latlng;\n            this.createIcon();\n        },\n\n        /**\n         * Create a styled circle location marker\n         */\n        createIcon() {\n            const opt = this.options;\n\n            let style = '';\n\n            if (opt.color !== undefined) {\n                style += `stroke:${opt.color};`;\n            }\n            if (opt.weight !== undefined) {\n                style += `stroke-width:${opt.weight};`;\n            }\n            if (opt.fillColor !== undefined) {\n                style += `fill:${opt.fillColor};`;\n            }\n            if (opt.fillOpacity !== undefined) {\n                style += `fill-opacity:${opt.fillOpacity};`;\n            }\n            if (opt.opacity !== undefined) {\n                style += `opacity:${opt.opacity};`;\n            }\n\n            const icon = this._getIconSVG(opt, style);\n\n            this._locationIcon = L.divIcon({\n                className: icon.className,\n                html: icon.svg,\n                iconSize: [icon.w,icon.h],\n            });\n\n            this.setIcon(this._locationIcon);\n        },\n\n        /**\n         * Return the raw svg for the shape\n         *\n         * Split so can be easily overridden\n         */\n        _getIconSVG(options, style) {\n            const r = options.radius;\n            const w = options.weight;\n            const s = r + w;\n            const s2 = s * 2;\n            const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` +\n            '<circle r=\"'+r+'\" style=\"'+style+'\" />' +\n            '</svg>';\n            return {\n                className: 'leaflet-control-locate-location',\n                svg,\n                w: s2,\n                h: s2\n            };\n        },\n\n        setStyle(style) {\n            L.Util.setOptions(this, style);\n            this.createIcon();\n        }\n    });\n\n    const CompassMarker = LocationMarker.extend({\n        initialize(latlng, heading, options) {\n            L.Util.setOptions(this, options);\n            this._latlng = latlng;\n            this._heading = heading;\n            this.createIcon();\n        },\n\n        setHeading(heading) {\n            this._heading = heading;\n        },\n\n        /**\n         * Create a styled arrow compass marker\n         */\n        _getIconSVG(options, style) {\n            const r = options.radius;\n            const w = (options.width + options.weight);\n            const h = (r+options.depth + options.weight)*2;\n            const path = `M0,0 l${options.width/2},${options.depth} l-${w},0 z`;\n            const svgstyle = `transform: rotate(${this._heading}deg)`;\n            const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${w}\" height=\"${h}\" version=\"1.1\" viewBox=\"-${w/2} 0 ${w} ${h}\" style=\"${svgstyle}\">`+\n            '<path d=\"'+path+'\" style=\"'+style+'\" />'+\n            '</svg>';\n            return {\n                className: 'leaflet-control-locate-heading',\n                svg,\n                w,\n                h\n            };\n        },\n    });\n\n\n    const LocateControl = L.Control.extend({\n        options: {\n            /** Position of the control */\n            position: 'topleft',\n            /** The layer that the user's location should be drawn on. By default creates a new layer. */\n            layer: undefined,\n            /**\n             * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n             * While the map is following the user's location, the control is in the `following` state,\n             * which changes the style of the control and the circle marker.\n             *\n             * Possible values:\n             *  - false: never updates the map view when location changes.\n             *  - 'once': set the view when the location is first determined\n             *  - 'always': always updates the map view when location changes.\n             *              The map view follows the user's location.\n             *  - 'untilPan': like 'always', except stops updating the\n             *                view if the user has manually panned the map.\n             *                The map view follows the user's location until she pans.\n             *  - 'untilPanOrZoom': (default) like 'always', except stops updating the\n             *                view if the user has manually panned the map.\n             *                The map view follows the user's location until she pans.\n             */\n            setView: 'untilPanOrZoom',\n            /** Keep the current map zoom level when setting the view and only pan. */\n            keepCurrentZoomLevel: false,\n     /** After activating the plugin by clicking on the icon, zoom to the selected zoom level, even when keepCurrentZoomLevel is true. Set to 'false' to disable this feature. */\n     initialZoomLevel: false,\n            /**\n             * This callback can be used to override the viewport tracking\n             * This function should return a LatLngBounds object.\n             *\n             * For example to extend the viewport to ensure that a particular LatLng is visible:\n             *\n             * getLocationBounds: function(locationEvent) {\n             *    return locationEvent.bounds.extend([-33.873085, 151.219273]);\n             * },\n             */\n            getLocationBounds(locationEvent) {\n                return locationEvent.bounds;\n            },\n            /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n            flyTo: false,\n            /**\n             * The user location can be inside and outside the current view when the user clicks on the\n             * control that is already active. Both cases can be configures separately.\n             * Possible values are:\n             *  - 'setView': zoom and pan to the current location\n             *  - 'stop': stop locating and remove the location marker\n             */\n            clickBehavior: {\n                /** What should happen if the user clicks on the control while the location is within the current view. */\n                inView: 'stop',\n                /** What should happen if the user clicks on the control while the location is outside the current view. */\n                outOfView: 'setView',\n                /**\n                 * What should happen if the user clicks on the control while the location is within the current view\n                 * and we could be following but are not. Defaults to a special value which inherits from 'inView';\n                 */\n                inViewNotFollowing: 'inView',\n            },\n            /**\n             * If set, save the map bounds just before centering to the user's\n             * location. When control is disabled, set the view back to the\n             * bounds that were saved.\n             */\n            returnToPrevBounds: false,\n            /**\n             * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n             * until the locate API returns a new location before they see where they are again.\n             */\n            cacheLocation: true,\n            /** If set, a circle that shows the location accuracy is drawn. */\n            drawCircle: true,\n            /** If set, the marker at the users' location is drawn. */\n            drawMarker: true,\n            /** If set and supported then show the compass heading */\n            showCompass: true,\n            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n            markerClass: LocationMarker,\n            /** The class us be used to create the compass bearing arrow */\n            compassClass: CompassMarker,\n            /** Accuracy circle style properties. NOTE these styles should match the css animations styles */\n            circleStyle: {\n                className:   'leaflet-control-locate-circle',\n                color:       '#136AEC',\n                fillColor:   '#136AEC',\n                fillOpacity: 0.15,\n                weight:      0\n            },\n            /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n            markerStyle: {\n                className:   'leaflet-control-locate-marker',\n                color:       '#fff',\n                fillColor:   '#2A93EE',\n                fillOpacity: 1,\n                weight:      3,\n                opacity:     1,\n                radius:      9\n            },\n            /** Compass */\n            compassStyle: {\n                fillColor:   '#2A93EE',\n                fillOpacity: 1,\n                weight:      0,\n                color:       '#fff',\n                opacity:     1,\n                radius:      9, // How far is the arrow is from the center of of the marker\n                width:       9, // Width of the arrow\n                depth:       6  // Length of the arrow\n            },\n            /**\n             * Changes to accuracy circle and inner marker while following.\n             * It is only necessary to provide the properties that should change.\n             */\n            followCircleStyle: {},\n            followMarkerStyle: {\n                // color: '#FFA500',\n                // fillColor: '#FFB000'\n            },\n            followCompassStyle: {},\n            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n            icon: 'leaflet-control-locate-location-arrow',\n            iconLoading: 'leaflet-control-locate-spinner',\n            /** The element to be created for icons. For example span or i */\n            iconElementTag: 'span',\n            /** The element to be created for the text. For example small or span */\n            textElementTag: 'small',\n            /** Padding around the accuracy circle. */\n            circlePadding: [0, 0],\n            /** Use metric units. */\n            metric: true,\n            /**\n             * This callback can be used in case you would like to override button creation behavior.\n             * This is useful for DOM manipulation frameworks such as angular etc.\n             * This function should return an object with HtmlElement for the button (link property) and the icon (icon property).\n             */\n            createButtonCallback(container, options) {\n                const link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);\n                link.title = options.strings.title;\n                link.href = '#';\n                link.setAttribute('role', 'button');\n                const icon = L.DomUtil.create(options.iconElementTag, options.icon, link);\n\n                if (options.strings.text !== undefined) {\n                    const text = L.DomUtil.create(options.textElementTag, 'leaflet-locate-text', link);\n                    text.textContent = options.strings.text;\n                    link.classList.add('leaflet-locate-text-active');\n                    link.parentNode.style.display = \"flex\";\n                    if (options.icon.length > 0) {\n                        icon.classList.add('leaflet-locate-icon');\n                    }\n                }\n\n                return { link, icon };\n            },\n            /** This event is called in case of any location error that is not a time out error. */\n            onLocationError(err, control) {\n                alert(err.message);\n            },\n            /**\n             * This event is called when the user's location is outside the bounds set on the map.\n             * The event is called repeatedly when the location changes.\n             */\n            onLocationOutsideMapBounds(control) {\n                control.stop();\n                alert(control.options.strings.outsideMapBoundsMsg);\n            },\n            /** Display a pop-up when the user click on the inner marker. */\n            showPopup: true,\n            strings: {\n                title: \"Show me where I am\",\n                metersUnit: \"meters\",\n                feetUnit: \"feet\",\n                popup: \"You are within {distance} {unit} from this point\",\n                outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n            },\n            /** The default options passed to leaflets locate method. */\n            locateOptions: {\n                maxZoom: Infinity,\n                watch: true,  // if you overwrite this, visualization cannot be updated\n                setView: false // have to set this to false because we have to\n                               // do setView manually\n            }\n        },\n\n        initialize(options) {\n            // set default options if nothing is set (merge one step deep)\n            for (const i in options) {\n                if (typeof this.options[i] === 'object') {\n                    L.extend(this.options[i], options[i]);\n                } else {\n                    this.options[i] = options[i];\n                }\n            }\n\n            // extend the follow marker style and circle from the normal style\n            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);\n            this.options.followCompassStyle = L.extend({}, this.options.compassStyle, this.options.followCompassStyle);\n        },\n\n        /**\n         * Add control to map. Returns the container for the control.\n         */\n        onAdd(map) {\n            const container = L.DomUtil.create('div',\n            'leaflet-control-locate leaflet-bar leaflet-control');\n            this._container = container;\n            this._map = map;\n            this._layer = this.options.layer || new L.LayerGroup();\n            this._layer.addTo(map);\n            this._event = undefined;\n            this._compassHeading = null;\n            this._prevBounds = null;\n\n            const linkAndIcon = this.options.createButtonCallback(container, this.options);\n            this._link = linkAndIcon.link;\n            this._icon = linkAndIcon.icon;\n\n            L.DomEvent.on(\n              this._link,\n              \"click\",\n              function (ev) {\n                L.DomEvent.stopPropagation(ev);\n                L.DomEvent.preventDefault(ev);\n                this._onClick();\n              },\n              this\n            ).on(this._link, \"dblclick\", L.DomEvent.stopPropagation);\n\n            this._resetVariables();\n\n            this._map.on('unload', this._unload, this);\n\n            return container;\n        },\n\n        /**\n         * This method is called when the user clicks on the control.\n         */\n        _onClick() {\n            this._justClicked = true;\n            const wasFollowing =  this._isFollowing();\n            this._userPanned = false;\n            this._userZoomed = false;\n\n            if (this._active && !this._event) {\n                // click while requesting\n                this.stop();\n            } else if (this._active) {\n                const behaviors = this.options.clickBehavior;\n                let behavior = behaviors.outOfView;\n                if (this._map.getBounds().contains(this._event.latlng)) {\n                    behavior = wasFollowing ? behaviors.inView : behaviors.inViewNotFollowing;\n                }\n\n                // Allow inheriting from another behavior\n                if (behaviors[behavior]) {\n                    behavior = behaviors[behavior];\n                }\n\n                switch (behavior) {\n                    case 'setView':\n                        this.setView();\n                        break;\n                    case 'stop':\n                        this.stop();\n                        if (this.options.returnToPrevBounds) {\n                            const f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n                            f.bind(this._map)(this._prevBounds);\n                        }\n                        break;\n                }\n            } else {\n                if (this.options.returnToPrevBounds) {\n                  this._prevBounds = this._map.getBounds();\n                }\n                this.start();\n            }\n\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Starts the plugin:\n         * - activates the engine\n         * - draws the marker (if coordinates available)\n         */\n        start() {\n            this._activate();\n\n            if (this._event) {\n                this._drawMarker(this._map);\n\n                // if we already have a location but the user clicked on the control\n                if (this.options.setView) {\n                    this.setView();\n                }\n            }\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Stops the plugin:\n         * - deactivates the engine\n         * - reinitializes the button\n         * - removes the marker\n         */\n        stop() {\n            this._deactivate();\n\n            this._cleanClasses();\n            this._resetVariables();\n\n            this._removeMarker();\n        },\n\n        /**\n         * Keep the control active but stop following the location\n         */\n        stopFollowing() {\n            this._userPanned = true;\n            this._updateContainerStyle();\n            this._drawMarker();\n        },\n\n        /**\n         * This method launches the location engine.\n         * It is called before the marker is updated,\n         * event if it does not mean that the event will be ready.\n         *\n         * Override it if you want to add more functionalities.\n         * It should set the this._active to true and do nothing if\n         * this._active is true.\n         */\n        _activate() {\n            if (!this._active) {\n                this._map.locate(this.options.locateOptions);\n                this._map.fire('locateactivate', this);\n                this._active = true;\n\n                // bind event listeners\n                this._map.on('locationfound', this._onLocationFound, this);\n                this._map.on('locationerror', this._onLocationError, this);\n                this._map.on('dragstart', this._onDrag, this);\n                this._map.on('zoomstart', this._onZoom, this);\n                this._map.on('zoomend', this._onZoomEnd, this);\n                if (this.options.showCompass) {\n                    const oriAbs = 'ondeviceorientationabsolute' in window;\n                    if (oriAbs || ('ondeviceorientation' in window)) {\n                        const _this = this;\n                        const deviceorientation = function () {\n                            L.DomEvent.on(window, oriAbs ? 'deviceorientationabsolute' : 'deviceorientation', _this._onDeviceOrientation, _this);\n                        };\n                        if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {\n                            DeviceOrientationEvent.requestPermission().then(function (permissionState) {\n                                if (permissionState === 'granted') {\n                                    deviceorientation();\n                                }\n                            });\n                        } else {\n                            deviceorientation();\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Called to stop the location engine.\n         *\n         * Override it to shutdown any functionalities you added on start.\n         */\n        _deactivate() {\n            this._map.stopLocate();\n            this._map.fire('locatedeactivate', this);\n            this._active = false;\n\n            if (!this.options.cacheLocation) {\n                this._event = undefined;\n            }\n\n            // unbind event listeners\n            this._map.off('locationfound', this._onLocationFound, this);\n            this._map.off('locationerror', this._onLocationError, this);\n            this._map.off('dragstart', this._onDrag, this);\n            this._map.off('zoomstart', this._onZoom, this);\n            this._map.off('zoomend', this._onZoomEnd, this);\n            if (this.options.showCompass) {\n                this._compassHeading = null;\n                if ('ondeviceorientationabsolute' in window) {\n                    L.DomEvent.off(window, 'deviceorientationabsolute', this._onDeviceOrientation, this);\n                } else if ('ondeviceorientation' in window) {\n                    L.DomEvent.off(window, 'deviceorientation', this._onDeviceOrientation, this);\n                }\n            }\n        },\n\n        /**\n         * Zoom (unless we should keep the zoom level) and an to the current view.\n         */\n        setView() {\n                    this._drawMarker();\n                    if (this._isOutsideMapBounds()) {\n                        this._event = undefined;  // clear the current location so we can get back into the bounds\n                        this.options.onLocationOutsideMapBounds(this);\n                    } else {\n                        if (this._justClicked && this.options.initialZoomLevel !== false) {\n                                    var f = this.options.flyTo ? this._map.flyTo : this._map.setView;\n                                    f.bind(this._map)([this._event.latitude, this._event.longitude], this.options.initialZoomLevel);\n                        } else if (this.options.keepCurrentZoomLevel) {\n                                    var f = this.options.flyTo ? this._map.flyTo : this._map.panTo;\n                                    f.bind(this._map)([this._event.latitude, this._event.longitude]);\n                        } else {\n                            var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n                            // Ignore zoom events while setting the viewport as these would stop following\n                            this._ignoreEvent = true;\n                            f.bind(this._map)(this.options.getLocationBounds(this._event), {\n                                padding: this.options.circlePadding,\n                                maxZoom: this.options.initialZoomLevel || this.options.locateOptions.maxZoom\n                            });\n                            L.Util.requestAnimFrame(function(){\n                                // Wait until after the next animFrame because the flyTo can be async\n                                this._ignoreEvent = false;\n                            }, this);\n\n                        }\n                    }\n                },\n\n        /**\n         *\n         */\n        _drawCompass() {\n            if (!this._event) {\n                return;\n            }\n\n            const latlng = this._event.latlng;\n\n            if (this.options.showCompass && latlng && this._compassHeading !== null) {\n                const cStyle = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle;\n                if (!this._compass) {\n                    this._compass = new this.options.compassClass(latlng, this._compassHeading, cStyle).addTo(this._layer);\n                } else {\n                    this._compass.setLatLng(latlng);\n                    this._compass.setHeading(this._compassHeading);\n                    // If the compassClass can be updated with setStyle, update it.\n                    if (this._compass.setStyle) {\n                        this._compass.setStyle(cStyle);\n                    }\n                }\n                //\n            }\n            if (this._compass && (!this.options.showCompass || this._compassHeading === null)) {\n                this._compass.removeFrom(this._layer);\n                this._compass = null;\n            }\n        },\n\n        /**\n         * Draw the marker and accuracy circle on the map.\n         *\n         * Uses the event retrieved from onLocationFound from the map.\n         */\n        _drawMarker() {\n            if (this._event.accuracy === undefined) {\n                this._event.accuracy = 0;\n            }\n\n            const radius = this._event.accuracy;\n            const latlng = this._event.latlng;\n\n            // circle with the radius of the location's accuracy\n            if (this.options.drawCircle) {\n                const style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n                if (!this._circle) {\n                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);\n                } else {\n                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n                }\n            }\n\n            let distance;\n            let unit;\n            if (this.options.metric) {\n                distance = radius.toFixed(0);\n                unit =  this.options.strings.metersUnit;\n            } else {\n                distance = (radius * 3.2808399).toFixed(0);\n                unit = this.options.strings.feetUnit;\n            }\n\n            // small inner marker\n            if (this.options.drawMarker) {\n                const mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n                if (!this._marker) {\n                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n                } else {\n                    this._marker.setLatLng(latlng);\n                    // If the markerClass can be updated with setStyle, update it.\n                    if (this._marker.setStyle) {\n                        this._marker.setStyle(mStyle);\n                    }\n                }\n            }\n\n            this._drawCompass();\n\n            const t = this.options.strings.popup;\n            function getPopupText() {\n                if (typeof t === 'string') {\n                    return L.Util.template(t, {distance, unit});\n                } else if (typeof t === 'function') {\n                    return t({distance, unit});\n                } else {\n                    return t;\n                }\n            }\n            if (this.options.showPopup && t && this._marker) {\n                this._marker\n                    .bindPopup(getPopupText())\n                    ._popup.setLatLng(latlng);\n            }\n            if (this.options.showPopup && t && this._compass) {\n                this._compass\n                    .bindPopup(getPopupText())\n                    ._popup.setLatLng(latlng);\n            }\n        },\n\n        /**\n         * Remove the marker from map.\n         */\n        _removeMarker() {\n            this._layer.clearLayers();\n            this._marker = undefined;\n            this._circle = undefined;\n        },\n\n        /**\n         * Unload the plugin and all event listeners.\n         * Kind of the opposite of onAdd.\n         */\n        _unload() {\n            this.stop();\n            this._map.off('unload', this._unload, this);\n        },\n\n        /**\n         * Sets the compass heading\n         */\n        _setCompassHeading(angle) {\n            if (!isNaN(parseFloat(angle)) && isFinite(angle)) {\n                angle = Math.round(angle);\n\n                this._compassHeading = angle;\n                L.Util.requestAnimFrame(this._drawCompass, this);\n            } else {\n                this._compassHeading = null;\n            }\n        },\n\n        /**\n         * If the compass fails calibration just fail safely and remove the compass\n         */\n        _onCompassNeedsCalibration() {\n            this._setCompassHeading();\n        },\n\n        /**\n         * Process and normalise compass events\n         */\n        _onDeviceOrientation(e) {\n            if (!this._active) {\n                return;\n            }\n\n            if (e.webkitCompassHeading) {\n                // iOS\n                this._setCompassHeading(e.webkitCompassHeading);\n            } else if (e.absolute && e.alpha) {\n                // Android\n                this._setCompassHeading(360 - e.alpha)\n            }\n        },\n\n        /**\n         * Calls deactivate and dispatches an error.\n         */\n        _onLocationError(err) {\n            // ignore time out error if the location is watched\n            if (err.code == 3 && this.options.locateOptions.watch) {\n                return;\n            }\n\n            this.stop();\n            this.options.onLocationError(err, this);\n        },\n\n        /**\n         * Stores the received event and updates the marker.\n         */\n        _onLocationFound(e) {\n            // no need to do anything if the location has not changed\n            if (this._event &&\n                (this._event.latlng.lat === e.latlng.lat &&\n                 this._event.latlng.lng === e.latlng.lng &&\n                     this._event.accuracy === e.accuracy)) {\n                return;\n            }\n\n            if (!this._active) {\n                // we may have a stray event\n                return;\n            }\n\n            this._event = e;\n\n            this._drawMarker();\n            this._updateContainerStyle();\n\n            switch (this.options.setView) {\n                case 'once':\n                    if (this._justClicked) {\n                        this.setView();\n                    }\n                    break;\n                case 'untilPan':\n                    if (!this._userPanned) {\n                        this.setView();\n                    }\n                    break;\n                case 'untilPanOrZoom':\n                    if (!this._userPanned && !this._userZoomed) {\n                        this.setView();\n                    }\n                    break;\n                case 'always':\n                    this.setView();\n                    break;\n                case false:\n                    // don't set the view\n                    break;\n            }\n\n            this._justClicked = false;\n        },\n\n        /**\n         * When the user drags. Need a separate event so we can bind and unbind event listeners.\n         */\n        _onDrag() {\n            // only react to drags once we have a location\n            if (this._event && !this._ignoreEvent) {\n                this._userPanned = true;\n                this._updateContainerStyle();\n                this._drawMarker();\n            }\n        },\n\n        /**\n         * When the user zooms. Need a separate event so we can bind and unbind event listeners.\n         */\n        _onZoom() {\n            // only react to drags once we have a location\n            if (this._event && !this._ignoreEvent) {\n                this._userZoomed = true;\n                this._updateContainerStyle();\n                this._drawMarker();\n            }\n        },\n\n        /**\n         * After a zoom ends update the compass and handle sideways zooms\n         */\n        _onZoomEnd() {\n            if (this._event) {\n                this._drawCompass();\n            }\n\n            if (this._event && !this._ignoreEvent) {\n                // If we have zoomed in and out and ended up sideways treat it as a pan\n                if (this._marker && !this._map.getBounds().pad(-.3).contains(this._marker.getLatLng())) {\n                    this._userPanned = true;\n                    this._updateContainerStyle();\n                    this._drawMarker();\n                }\n            }\n        },\n\n        /**\n         * Compute whether the map is following the user location with pan and zoom.\n         */\n        _isFollowing() {\n            if (!this._active) {\n                return false;\n            }\n\n            if (this.options.setView === 'always') {\n                return true;\n            } else if (this.options.setView === 'untilPan') {\n                return !this._userPanned;\n            } else if (this.options.setView === 'untilPanOrZoom') {\n                return !this._userPanned && !this._userZoomed;\n            }\n        },\n\n        /**\n         * Check if location is in map bounds\n         */\n        _isOutsideMapBounds() {\n            if (this._event === undefined) {\n                return false;\n            }\n            return this._map.options.maxBounds &&\n                !this._map.options.maxBounds.contains(this._event.latlng);\n        },\n\n        /**\n         * Toggles button class between following and active.\n         */\n        _updateContainerStyle() {\n            if (!this._container) {\n                return;\n            }\n\n            if (this._active && !this._event) {\n                // active but don't have a location yet\n                this._setClasses('requesting');\n            } else if (this._isFollowing()) {\n                this._setClasses('following');\n            } else if (this._active) {\n                this._setClasses('active');\n            } else {\n                this._cleanClasses();\n            }\n        },\n\n        /**\n         * Sets the CSS classes for the state.\n         */\n        _setClasses(state) {\n            if (state == 'requesting') {\n                removeClasses(this._container, \"active following\");\n                addClasses(this._container, \"requesting\");\n\n                removeClasses(this._icon, this.options.icon);\n                addClasses(this._icon, this.options.iconLoading);\n            } else if (state == 'active') {\n                removeClasses(this._container, \"requesting following\");\n                addClasses(this._container, \"active\");\n\n                removeClasses(this._icon, this.options.iconLoading);\n                addClasses(this._icon, this.options.icon);\n            } else if (state == 'following') {\n                removeClasses(this._container, \"requesting\");\n                addClasses(this._container, \"active following\");\n\n                removeClasses(this._icon, this.options.iconLoading);\n                addClasses(this._icon, this.options.icon);\n            }\n        },\n\n        /**\n         * Removes all classes from button.\n         */\n        _cleanClasses() {\n            L.DomUtil.removeClass(this._container, \"requesting\");\n            L.DomUtil.removeClass(this._container, \"active\");\n            L.DomUtil.removeClass(this._container, \"following\");\n\n            removeClasses(this._icon, this.options.iconLoading);\n            addClasses(this._icon, this.options.icon);\n        },\n\n        /**\n         * Reinitializes state variables.\n         */\n        _resetVariables() {\n            // whether locate is active or not\n            this._active = false;\n\n            // true if the control was clicked for the first time\n            // we need this so we can pan and zoom once we have the location\n            this._justClicked = false;\n\n            // true if the user has panned the map after clicking the control\n            this._userPanned = false;\n\n            // true if the user has zoomed the map after clicking the control\n            this._userZoomed = false;\n        }\n    });\n\n    L.control.locate = (options) => new L.Control.Locate(options);\n\n    return LocateControl;\n}, window));\n"],"names":["factory","window","L","Control","Locate","LDomUtilApplyClassesMethod","method","element","classNames","split","forEach","className","DomUtil","call","this","addClasses","el","names","removeClasses","LocationMarker","Marker","extend","initialize","latlng","options","Util","setOptions","_latlng","createIcon","opt","style","undefined","color","weight","fillColor","fillOpacity","opacity","icon","_getIconSVG","_locationIcon","divIcon","html","svg","iconSize","w","h","setIcon","r","radius","s","s2","setStyle","CompassMarker","heading","_heading","setHeading","width","depth","path","LocateControl","position","layer","setView","keepCurrentZoomLevel","initialZoomLevel","getLocationBounds","locationEvent","bounds","flyTo","clickBehavior","inView","outOfView","inViewNotFollowing","returnToPrevBounds","cacheLocation","drawCircle","drawMarker","showCompass","markerClass","compassClass","circleStyle","markerStyle","compassStyle","followCircleStyle","followMarkerStyle","followCompassStyle","iconLoading","iconElementTag","textElementTag","circlePadding","metric","createButtonCallback","container","link","create","title","strings","href","setAttribute","text","textContent","classList","add","parentNode","display","length","onLocationError","err","control","alert","message","onLocationOutsideMapBounds","stop","outsideMapBoundsMsg","showPopup","metersUnit","feetUnit","popup","locateOptions","maxZoom","Infinity","watch","i","onAdd","map","_container","_map","_layer","LayerGroup","addTo","_event","_compassHeading","_prevBounds","linkAndIcon","_link","_icon","DomEvent","on","ev","stopPropagation","preventDefault","_onClick","_resetVariables","_unload","_justClicked","wasFollowing","_isFollowing","_userPanned","_userZoomed","_active","behaviors","behavior","getBounds","contains","flyToBounds","fitBounds","bind","f","start","_updateContainerStyle","_activate","_drawMarker","_deactivate","_cleanClasses","_removeMarker","stopFollowing","locate","fire","_onLocationFound","_onLocationError","_onDrag","_onZoom","_onZoomEnd","oriAbs","_this","deviceorientation","_onDeviceOrientation","DeviceOrientationEvent","requestPermission","then","permissionState","stopLocate","off","_isOutsideMapBounds","latitude","longitude","panTo","_ignoreEvent","padding","requestAnimFrame","_drawCompass","cStyle","_compass","setLatLng","removeFrom","accuracy","_circle","setRadius","circle","distance","unit","toFixed","mStyle","_marker","t","getPopupText","template","bindPopup","_popup","clearLayers","_setCompassHeading","angle","isNaN","parseFloat","isFinite","Math","round","_onCompassNeedsCalibration","e","webkitCompassHeading","absolute","alpha","code","lat","lng","pad","getLatLng","maxBounds","_setClasses","state","removeClass"],"sourceRoot":""}